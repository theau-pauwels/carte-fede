---
import Layout from "../../layouts/Layout.astro";
---
<Layout title="Gestion des utilisateurs">
  <h1>Gestion des utilisateurs</h1>
  <p><a href="/admin" class="btn">‚Üê Admin</a></p>

  <table id="tbl">
    <thead>
      <tr>
        <th>Nom</th>
        <th>Pr√©nom</th>
        <th>Identifiant</th>
        <th>Cartes (ann√©e ‚Üí n¬∞)</th>
        <th>Ajouter une carte</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
</Layout>

<script>
  const ALLOWED_PREFIXES = ["A","F","E","EA","MI","S"];

  // ---------- Utilitaires ann√©e ----------
function academicStartYearNow() {
  // Septembre = d√©but d'ann√©e scolaire
  const d = new Date();
  const y = d.getFullYear();
  const m = d.getMonth() + 1;
  return (m >= 9) ? y : (y - 1);
}

function makeYearRangesFrom2022(yearsAhead = 6) {
  // G√©n√®re ["2022-2023", ..., "YYYY-YYYY+1"] jusqu'√† l'ann√©e courante + yearsAhead
  const start = 2022;
  const end = academicStartYearNow() + yearsAhead;
  const arr = [];
  for (let y = start; y <= end; y++) {
    arr.push(`${y}-${y + 1}`);
  }
  return arr;
}

function yearRangeLabelFromStart(startYear) { return `${startYear}-${startYear+1}`; }

function startYearFromLabel(label) {
  const s = String(label||"").trim();
  const left = s.includes("-") ? s.split("-")[0] : s;
  const n = parseInt(left, 10);
  return Number.isFinite(n) ? n : null;
}


  // ---------- Index des num√©ros pris ----------
  // taken[yearStart][prefix] = Set(numbers)
  function buildTakenIndex(users) {
    const taken = {};
    for (const u of users) {
      const cartes = u.cartes || {};
      for (const [yearStr, code] of Object.entries(cartes)) {
        const year = parseInt(yearStr, 10);
        if (!Number.isFinite(year)) continue;
        if (typeof code !== "string") continue;
        const [rawPrefix, rawNum] = code.toUpperCase().split("-");
        if (!rawPrefix || !rawNum || !/^\d+$/.test(rawNum)) continue;
        const prefix = rawPrefix.trim();
        const num = parseInt(rawNum, 10);
        if (!ALLOWED_PREFIXES.includes(prefix) || num < 1) continue;

        if (!taken[year]) taken[year] = {};
        if (!taken[year][prefix]) taken[year][prefix] = new Set();
        taken[year][prefix].add(num);
      }
    }
    return taken;
  }

  function nextFreeNumber(taken, yearStart, prefix) {
    // renvoie le plus petit entier >=1 non utilis√© pour (ann√©e,prefix)
    if (!yearStart || !prefix) return 1;
    const used = taken?.[yearStart]?.[prefix];
    if (!used) return 1;
    let n = 1;
    while (used.has(n)) n++;
    return n;
  }

  // ---------- API ----------
  async function ensureAdmin() {
    const me = await fetch('/api/me', { credentials: 'include' });
    if (!me.ok) { location.href = '/login?next=' + encodeURIComponent(location.pathname); return false; }
    const j = await me.json();
    if (j.role !== 'admin') { location.href = '/'; return false; }
    return true;
  }

  async function fetchUsers() {
    const res = await fetch('/api/admin/users', { credentials: 'include' });
    if (!res.ok) throw new Error('HTTP '+res.status);
    return res.json();
  }

  // ---------- Rendu ----------
  function render(users) {
    const tb = document.querySelector('#tbl tbody');
    const fmtCartes = (cartes) => {
      const entries = Object.entries(cartes || {});
      if (!entries.length) return '<span class="muted">‚Äî</span>';
      entries.sort((a,b)=>Number(b[0])-Number(a[0]));
      return entries.map(([y,c]) => `${yearRangeLabelFromStart(Number(y))} ‚Üí ${c}`).join('<br/>');
    };

    const currentStart = academicStartYearNow();
    const yearRanges = makeYearRangesFrom2022(); // ["2022-2023", ..., courant+N]
    const optionsHtml = yearRanges.map(r => {
      const yStart = startYearFromLabel(r);
      const sel = (yStart === currentStart) ? ' selected' : '';
      return `<option value="${r}"${sel}>${r}</option>`;
    }).join('');


    // Index global des num√©ros d√©j√† utilis√©s (tous users)
    const taken = buildTakenIndex(users);

    tb.innerHTML = users.map(u => `
      <tr>
        <td>${u.nom}</td>
        <td>${u.prenom}</td>
        <td>${u.identifiant ?? ''}</td>
        <td>${fmtCartes(u.cartes)}</td>
        <td>
          <form class="inline form-carte" data-user="${u.id}">
            <select name="annee" required>
              ${optionsHtml}
            </select>
            <select name="prefix" required>
              ${ALLOWED_PREFIXES.map(p => `<option value="${p}">${p}</option>`).join('')}
            </select>
            <input type="text" name="num" placeholder="Num√©ro" required pattern="\\d+" inputmode="numeric" />
            <button type="submit">‚ûï</button>
            <small class="muted" style="display:block">Format: PREFIX-Num (ex: A-23). Les z√©ros en t√™te sont ignor√©s.</small>
          </form>
        </td>
      </tr>
    `).join('');

    // Pour chaque ligne, initialiser le "num" avec le premier libre et g√©rer les changements
    document.querySelectorAll('.form-carte').forEach(f => {
      const selYear = f.querySelector('select[name="annee"]');
      const selPrefix = f.querySelector('select[name="prefix"]');
      const inputNum = f.querySelector('input[name="num"]');

      // ... √† la place de ta version actuelle :

      function refreshDefaultNumber(force = false) {
        const yearStart = startYearFromLabel(selYear.value);
        const prefix = String(selPrefix.value||'').toUpperCase();
        const suggestion = nextFreeNumber(taken, yearStart, prefix);

        // si force=true (changement de prefix/ann√©e) -> remplace toujours
        // sinon, on ne remplace que si le champ est vide/invalide
        if (force || !/^\d+$/.test(inputNum.value)) {
          inputNum.value = String(suggestion);
        }
        inputNum.placeholder = String(suggestion);
      }

      // √©couteurs :
      selYear.addEventListener('change', () => refreshDefaultNumber(true));   // üëà force
      selPrefix.addEventListener('change', () => refreshDefaultNumber(true)); // üëà force

      // init
      refreshDefaultNumber(true);


      f.addEventListener('submit', async (e) => {
        e.preventDefault();
        const userId = f.dataset.user;

        const yearStart = startYearFromLabel(selYear.value);
        const prefix = String(selPrefix.value||'').toUpperCase();

        let numRaw = String(inputNum.value||'').trim();
        if (!/^\d+$/.test(numRaw)) {
          // fallback : si vide ou invalide, utiliser le premier libre
          numRaw = String(nextFreeNumber(taken, yearStart, prefix));
        }
        const num = parseInt(numRaw, 10);
        if (!Number.isFinite(num) || num < 1) {
          alert("Le num√©ro doit √™tre un entier ‚â• 1");
          return;
        }
        if (!ALLOWED_PREFIXES.includes(prefix)) {
          alert("Pr√©fixe invalide");
          return;
        }

        const anneeLabel = selYear.value; // "YYYY-YYYY+1"
        const annee_code = `${prefix}-${num}`;

        const r = await fetch(`/api/admin/users/${userId}/annees`, {
          method:'PUT',
          headers:{'Content-Type':'application/json'},
          credentials:'include',
          body: JSON.stringify({ annee: anneeLabel, annee_code })
        });

        if (!r.ok) {
          if (r.status === 409) {
            alert("Ce num√©ro de carte est d√©j√† utilis√© pour cette ann√©e.");
            return;
          }
          let msg = 'Erreur ' + r.status;
          try { const j=await r.json(); if (j.error) msg=j.error; } catch {}
          alert(msg);
          return;
        }

        // Met √† jour l'index local "taken" pour √©viter un refetch complet
        if (!taken[yearStart]) taken[yearStart] = {};
        if (!taken[yearStart][prefix]) taken[yearStart][prefix] = new Set();
        taken[yearStart][prefix].add(num);

        // Rafra√Æchir la table c√¥t√© UI (refetch pour refl√©ter toutes les colonnes)
        const users = await fetchUsers();
        render(users);
      });
    });
  }

  (async () => {
    if (!await ensureAdmin()) return;
    try { render(await fetchUsers()); }
    catch (e) { alert('Chargement impossible: '+e.message); }
  })();
</script>
